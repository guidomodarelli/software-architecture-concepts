# Arquitectura de Microservicios

La arquitectura de microservicios es un estilo arquitectónico más **reciente** en comparación con la arquitectura monolítica. A diferencia de la monolítica, donde el *software* se construye como una única unidad, los microservicios implican construir los **subdominios** de la aplicación como **servicios separados**.

## Definición y Estructura

La arquitectura de microservicios es un estilo que estructura una aplicación como una **colección de servicios pequeños e implementables de forma independiente**. En contraste con un monolito, donde todos los subdominios están en una unidad, en microservicios estos subdominios son servicios que pueden implementarse de manera independiente.

---

## Descripción General del Flujo

En un enfoque típico, el flujo de comunicación se ve así:

1.  **Clientes** (navegador web, móvil)
2.  **API Gateway** (Puerta de Enlace API)
3.  **Microservicios**

* Este es el enfoque que se utilizará en la aplicación que se construirá: la comunicación siempre será **Cliente $\rightarrow$ API Gateway $\rightarrow$ Microservicios**.
* Existe otro enfoque (no utilizado aquí) donde la comunicación puede ser directa de **Cliente $\rightarrow$ Microservicio**.

---

## Características Clave de los Microservicios

Cada microservicio es manejado como una **aplicación separada**.

* **Pila Tecnológica Propia:** Cada microservicio puede tener su propia **pila tecnológica** y estructura.
* **Base de Datos Propia:** Tienen sus propias bases de datos y **no** comparten una base de datos centralizada. Se utiliza el enfoque de **base de datos por servicio** para mejorar el aislamiento y la seguridad de los datos.
* **Orientación:** Está orientado principalmente al ***backend***, aunque el enfoque se está utilizando más recientemente en el *frontend* con el concepto de **micro-frontends**.

---

## Comunicación entre Servicios

Los servicios se comunican a través de **APIs bien definidas**.

* **Protocolos Comunes:** Los protocolos de comunicación incluyen:
    * HTTP o HTTPS
    * WebSockets
    * **Advanced Message Queue Protocol (AMQP)** – Se utilizará para la comunicación basada en eventos (al implementar RabbitMQ).
* **Estilos de Comunicación:** Se pueden usar estilos de comunicación **síncronos** y **asíncronos**.
* **Tecnologías de API:** Para la comunicación se pueden utilizar:
    * **REST APIs**
    * **GraphQL**
    * **WebSockets**
* **Enfoque de la Aplicación:** Se utilizará un enfoque **síncrono** y **asíncrono** para la comunicación, y los **eventos** se usarán específicamente para la comunicación **entre microservicios**.

---

## Ejemplo en Aplicación de Comercio Electrónico

En una aplicación de comercio electrónico, las funcionalidades podrían dividirse en servicios separados:

* **Autenticación** (servicio separado)
* **Productos** (servicio separado)
* **Pagos** (servicio separado)
* **Pedidos** (servicio separado)
* *Cada uno con acceso a su propia base de datos.*

---

## ✅ Beneficios de la Arquitectura de Microservicios

La arquitectura de microservicios ofrece múltiples ventajas:

1️⃣ **Escalabilidad**
* Permite escalar cada servicio de forma **independiente** para satisfacer la demanda de la característica específica que soporta.
* Se puede escalar una parte con alta demanda (*scale out*) y reducir recursos en otra (*scale in*) **sin afectar a los demás servicios**.

2️⃣ **Desarrollo más Rápido**
* Los equipos pueden trabajar y lanzar servicios individuales de forma **independiente**, lo que acelera los ciclos de desarrollo.

3️⃣ **Flexibilidad en la Pila Tecnológica**
* A diferencia de la arquitectura monolítica, donde se usa una sola pila, aquí los equipos pueden **elegir las mejores herramientas y lenguajes** de programación para tareas específicas (ej.: Python para autenticación, Java para pagos, .NET para productos).

4️⃣ **Aislamiento de Fallos (Tolerancia a Fallos)**
* Los microservicios están diseñados para ser tolerantes a fallos. Si un servicio falla (ej.: el sistema de pagos), **no necesariamente afecta a todo el sistema** (ej.: el sistema de autenticación y la lista de productos siguen funcionando).

5️⃣ **Mantenibilidad Mejorada**
* Los servicios más pequeños son **más fáciles de entender, mantener y actualizar**.
* Un nuevo desarrollador solo necesita comprender el dominio o el servicio en el que está trabajando, **sin necesidad de conocer el funcionamiento interno** de los demás servicios.

6️⃣ **Aislamiento y Seguridad de Datos**
* Los servicios tienen sus propias soluciones de almacenamiento de datos, lo que mejora el **aislamiento** y la **seguridad** de los datos. Se utiliza el enfoque de **base de datos por servicio**.

7️⃣ **Monitoreo y Observabilidad Mejorados**
* Cada servicio puede tener sus propias herramientas de monitoreo, lo que facilita el **seguimiento del rendimiento**, la **resolución de problemas** y la obtención de información sobre el comportamiento del sistema.
* En la aplicación se utilizará una herramienta (Elasticsearch y Kibana) donde los servicios estarán **aislados** en el *dashboard* de monitoreo, permitiendo ver los registros (*logs*) de cada uno por separado.

8️⃣ **Facilidad de Implementación (*Deployment*)**
* Los microservicios facilitan la **Integración Continua (CI)** y la **Entrega Continua (CD)**.
* Dado que cada servicio tiene sus propias *pipelines*, se pueden **implementar de forma independiente** de los demás servicios.

---

## ❌ Desafíos de la Arquitectura de Microservicios

La complejidad de los microservicios presenta varios retos:

1️⃣ **Complejidad Operacional**
* Gestionar un gran número de microservicios puede ser complejo en términos de **infraestructura**, **herramientas de implementación** y **monitoreo**.

2️⃣ **Comunicación entre Servicios (*Inter-service Communication*)**
* La comunicación entre microservicios (no del cliente al servicio) depende de la **comunicación de red**.
* Si no se construye correctamente, puede haber problemas de **latencia**, **confiabilidad** y **coherencia de los datos**.

3️⃣ **Pruebas y Depuración (*Debugging*)**
* Probar microservicios individualmente y garantizar la **integración adecuada** puede ser un desafío.
* Depurar problemas que se extienden a lo largo de **múltiples servicios** puede ser complejo y llevar mucho tiempo.

4️⃣ **Seguridad y Cumplimiento (*Compliance*)**
* La seguridad es más desafiante ya que hay **más puntos de entrada potenciales** para brechas de seguridad.
* *Medida de Seguridad para la Aplicación:* Para mejorar la seguridad, **no se permitirán comunicaciones externas directas** a los servicios; todas las solicitudes pasarán por la **API Gateway**.

5️⃣ **Monitoreo y Observabilidad**
* Monitorear **múltiples servicios** puede ser complejo.

6️⃣ **Comunicación y Colaboración del Equipo**
* Puede haber problemas de comunicación y colaboración al trabajar en tantos servicios independientes.